<!DOCTYPE html>
<html lang="zh-CN"><head><meta charset="utf-8"/><link href="/img/fluid.png" rel="apple-touch-icon" sizes="76x76"/><link href="/img/fluid.png" rel="icon"/><meta content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no" name="viewport"/><meta content="ie=edge" http-equiv="x-ua-compatible"/><meta content="upgrade-insecure-requests" http-equiv="Content-Security-Policy"/><meta content="#2f4154" name="theme-color"/><meta content="Nichuanfang" name="author"/><meta content="" name="keywords"/><meta content="前言哈喽，大家好。平时我们写代码呢，多数情况都是流水线式写代码，基本就可以实现业务逻辑了。如何在写代码中找到乐趣呢，我觉得，最好的方式就是：使用设计模式优化自己的业务代码。今天跟大家聊聊日常工作中，我都使用过哪些设计模式。  工作中常用到哪些设计模式 1.策略模式1.1 业务场景假设有这样的业务场景，大数据系统把文件推送过来，根据不同类型采取不同的解析方式。多数的小伙伴就会写出以下的代码：  if" name="description"/><meta content="article" property="og:type"/><meta content="工作中重要的设计模式" property="og:title"/><meta content="https://blog.chuanfang.org/2024/09/12/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" property="og:url"/><meta content="个人博客" property="og:site_name"/><meta content="前言哈喽，大家好。平时我们写代码呢，多数情况都是流水线式写代码，基本就可以实现业务逻辑了。如何在写代码中找到乐趣呢，我觉得，最好的方式就是：使用设计模式优化自己的业务代码。今天跟大家聊聊日常工作中，我都使用过哪些设计模式。  工作中常用到哪些设计模式 1.策略模式1.1 业务场景假设有这样的业务场景，大数据系统把文件推送过来，根据不同类型采取不同的解析方式。多数的小伙伴就会写出以下的代码：  if" property="og:description"/><meta content="zh_CN" property="og:locale"/><meta content="https://blog.chuanfang.org/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.webp" property="og:image"/><meta content="2024-09-12T14:36:01.000Z" property="article:published_time"/><meta content="2024-09-12T15:10:59.000Z" property="article:modified_time"/><meta content="Nichuanfang" property="article:author"/><meta content="设计" property="article:tag"/><meta content="summary_large_image" name="twitter:card"/><meta content="https://blog.chuanfang.org/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.webp" name="twitter:image"/><title>工作中重要的设计模式 - 个人博客</title><link href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" rel="stylesheet"/><link href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" rel="stylesheet"/><link href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" rel="stylesheet"/><link href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css" rel="stylesheet"/><link href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css" rel="stylesheet"/><link href="/css/main.css" rel="stylesheet"/><link href="/css/highlight.css" id="highlight-css" rel="stylesheet"/><link href="/css/culture.css" rel="stylesheet"/><link href="/css/custom.css" rel="stylesheet"/><link href="/css/APlayer.min.css" rel="stylesheet"/><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog.chuanfang.org",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!1,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:0},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><link href="/css/all.min.css" rel="stylesheet"/><script src="/js/culture_init.js"></script><script src="/js/culture/movie.js"></script><script src="/js/culture/movie_detail.js"></script><script src="/js/culture/show.js"></script><script src="/js/culture/show_detail.js"></script><meta content="Hexo 7.0.0" name="generator"/></head><body><div id="background-image" style="display:none;left:330.067px"><img alt="Background image" lazyload="" src="/img/bg/bg01.png" srcset="/img/loading.gif"/></div><header><div class="header-inner" style="height:62vh"><nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar" id="navbar"><div class="container"><a class="navbar-brand" href="/"><strong>文森特 World</strong> </a><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" id="navbar-toggler-btn" type="button"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/culture/" target="_self"><i class="iconfont icon-music"></i> <span>文艺</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a aria-label="Search" class="nav-link" data-target="#modalSearch" data-toggle="modal" href="javascript:;" target="_self"><i class="iconfont icon-search"></i></a></li></ul></div></div></nav><div class="banner" false="" id="banner" style="background:url(/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.webp) no-repeat center 30%;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,0)"><div class="banner-text text-center fade-in-up"><div class="h2"><span data-typed-text="工作中重要的设计模式" id="subtitle"></span></div><div class="mt-3"><span class="post-meta"><i aria-hidden="true" class="iconfont icon-date-fill"></i> <time datetime="2024-09-12 22:36" pubdate="">2024年9月12日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">工作中重要的设计模式</h1><div class="markdown-body"><h3 id="前言"><a class="headerlink" href="#前言" title="前言"></a>前言</h3><p>哈喽，大家好。平时我们写代码呢，多数情况都是<strong>流水线式</strong>写代码，基本就可以实现业务逻辑了。<strong>如何在写代码中找到乐趣呢</strong>，我觉得，最好的方式就是：<strong>使用设计模式优化自己的业务代码</strong>。今天跟大家聊聊日常工作中，我都使用过哪些设计模式。</p><p><img lazyload="" src="/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/deb26b4dbe163d4df2f0f0c055a7319d.webp" srcset="/img/loading.gif"/></p><p>工作中常用到哪些设计模式</p><h3 id="1-策略模式"><a class="headerlink" href="#1-策略模式" title="1.策略模式"></a>1.策略模式</h3><h4 id="1-1-业务场景"><a class="headerlink" href="#1-1-业务场景" title="1.1 业务场景"></a>1.1 业务场景</h4><p>假设有这样的业务场景，大数据系统把文件推送过来，根据不同类型采取<strong>不同的解析</strong>方式。多数的小伙伴就会写出以下的代码：</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span>==<span class="hljs-string">"A"</span>){

   <span class="hljs-comment">//按照A格式解析</span>



}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span>==<span class="hljs-string">"B"</span>){

    <span class="hljs-comment">//按B格式解析</span>

}<span class="hljs-keyword">else</span>{

    <span class="hljs-comment">//按照默认格式解析</span>

}</code></pre></div><p>这个代码可能会存在哪些<strong>问题呢</strong>？</p><ul><li>如果分支变多，这里的代码就会变得<strong>臃肿，难以维护，可读性低</strong>。</li><li>如果你需要接入一种新的解析类型，那只能在<strong>原有代码上修改</strong>。</li></ul><p>说得专业一点的话，就是以上代码，违背了<a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020" rel="noopener" target="_blank">面向对象编程</a>的<strong>开闭原则</strong>以及<strong>单一原则</strong>。</p><ul><li><strong>开闭原则</strong>（对于扩展是开放的，但是对于修改是封闭的）：增加或者删除某个逻辑，都需要修改到原来代码</li><li><strong>单一原则</strong>（规定一个类应该只有一个发生变化的原因）：修改任何类型的分支逻辑代码，都需要改动当前类的代码。</li></ul><p>如果你的代码就是酱紫：有多个<code>if...else</code>等条件分支，并且每个条件分支，可以封装起来替换的，我们就可以使用<strong>策略模式</strong>来优化。</p><h4 id="1-2-策略模式定义"><a class="headerlink" href="#1-2-策略模式定义" title="1.2 策略模式定义"></a>1.2 策略模式定义</h4><p><strong>策略模式</strong>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的的客户。这个策略模式的定义是不是有点抽象呢？那我们来看点通俗易懂的比喻：</p><blockquote><p>假设你跟不同性格类型的小姐姐约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去逛街买买买最合适。当然，目的都是为了得到小姐姐的芳心，请看电影、吃小吃、逛街就是不同的策略。</p></blockquote><p>策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p><h4 id="1-3-策略模式使用"><a class="headerlink" href="#1-3-策略模式使用" title="1.3 策略模式使用"></a>1.3 策略模式使用</h4><p>策略模式怎么使用呢？酱紫实现的：</p><ul><li>一个接口或者抽象类，里面两个方法（一个方法匹配类型，一个可替换的逻辑实现方法）</li><li>不同策略的差异化实现(就是说，不同策略的实现类)</li><li>使用策略模式</li></ul><h5 id="1-3-1-一个接口，两个方法"><a class="headerlink" href="#1-3-1-一个接口，两个方法" title="1.3.1 一个接口，两个方法"></a>1.3.1 一个接口，两个方法</h5><div class="code-wrapper"><pre><code class="hljs go">
public <span class="hljs-keyword">interface</span> IFileStrategy {



    <span class="hljs-comment">//属于哪种文件解析类型</span>

    FileTypeResolveEnum gainFileType();



    <span class="hljs-comment">//封装的公用算法（具体的解析方法）</span>

    void resolve(Object objectparam);

}</code></pre></div><h5 id="1-3-2-不同策略的差异化实现"><a class="headerlink" href="#1-3-2-不同策略的差异化实现" title="1.3.2 不同策略的差异化实现"></a>1.3.2 不同策略的差异化实现</h5><p>A 类型策略具体实现</p><div class="code-wrapper"><pre><code class="hljs go">
@Component

public class AFileResolve implements IFileStrategy {



    @Override

    public FileTypeResolveEnum gainFileType() {

        <span class="hljs-keyword">return</span> FileTypeResolveEnum.File_A_RESOLVE;

    }



    @Override

    public void resolve(Object objectparam) {

      logger.info(<span class="hljs-string">"A 类型解析文件，参数：{}"</span>,objectparam);

      <span class="hljs-comment">//A类型解析具体逻辑</span>

    }

}</code></pre></div><p>B 类型策略具体实现</p><div class="code-wrapper"><pre><code class="hljs go">
@Component

public class BFileResolve implements IFileStrategy {



    @Override

    public FileTypeResolveEnum gainFileType() {

        <span class="hljs-keyword">return</span> FileTypeResolveEnum.File_B_RESOLVE;

    }





    @Override

    public void resolve(Object objectparam) {

      logger.info(<span class="hljs-string">"B 类型解析文件，参数：{}"</span>,objectparam);

      <span class="hljs-comment">//B类型解析具体逻辑</span>

    }

}</code></pre></div><p>默认类型策略具体实现</p><div class="code-wrapper"><pre><code class="hljs go">
@Component

public class DefaultFileResolve implements IFileStrategy {



    @Override

    public FileTypeResolveEnum gainFileType() {

        <span class="hljs-keyword">return</span> FileTypeResolveEnum.File_DEFAULT_RESOLVE;

    }



    @Override

    public void resolve(Object objectparam) {

      logger.info(<span class="hljs-string">"默认类型解析文件，参数：{}"</span>,objectparam);

      <span class="hljs-comment">//默认类型解析具体逻辑</span>

    }

}</code></pre></div><h5 id="1-3-3-使用策略模式"><a class="headerlink" href="#1-3-3-使用策略模式" title="1.3.3 使用策略模式"></a>1.3.3 使用策略模式</h5><p>如何使用呢？我们借助<code>spring</code>的生命周期，使用<code>ApplicationContextAware</code>接口，把对用的策略，初始化到<code>map</code>里面。然后对外提供<code>resolveFile</code>方法即可。</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  @author 公众号：捡田螺的小男孩</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

@Component

public class StrategyUseService implements ApplicationContextAware{





    private Map&lt;FileTypeResolveEnum, IFileStrategy&gt; iFileStrategyMap = <span class="hljs-built_in">new</span> ConcurrentHashMap&lt;&gt;();



    public void resolveFile(FileTypeResolveEnum fileTypeResolveEnum, Object objectParam) {

        IFileStrategy iFileStrategy = iFileStrategyMap.get(fileTypeResolveEnum);

        <span class="hljs-keyword">if</span> (iFileStrategy != null) {

            iFileStrategy.resolve(objectParam);

        }

    }



    <span class="hljs-comment">//把不同策略放到map</span>

    @Override

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {

        Map&lt;String, IFileStrategy&gt; tmepMap = applicationContext.getBeansOfType(IFileStrategy.class);

        tmepMap.values().forEach(strategyService -&gt; iFileStrategyMap.put(strategyService.gainFileType(), strategyService));

    }

}</code></pre></div><h3 id="2-责任链模式"><a class="headerlink" href="#2-责任链模式" title="2. 责任链模式"></a>2. 责任链模式</h3><h4 id="2-1-业务场景"><a class="headerlink" href="#2-1-业务场景" title="2.1 业务场景"></a>2.1 业务场景</h4><p>我们来看一个常见的业务场景，下订单。下订单接口，基本的逻辑，一般有参数非空校验、安全校验、黑名单校验、规则拦截等等。很多伙伴会使用异常来实现：</p><div class="code-wrapper"><pre><code class="hljs go">
public class Order {



    public void checkNullParam(Object param){

      <span class="hljs-comment">//参数非空校验</span>

      throw <span class="hljs-built_in">new</span> RuntimeException();

    }

    public void checkSecurity(){

      <span class="hljs-comment">//安全校验</span>

      throw <span class="hljs-built_in">new</span> RuntimeException();

    }

    public void checkBackList(){

        <span class="hljs-comment">//黑名单校验</span>

        throw <span class="hljs-built_in">new</span> RuntimeException();

    }

    public void checkRule(){

        <span class="hljs-comment">//规则拦截</span>

        throw <span class="hljs-built_in">new</span> RuntimeException();

    }



    public static void main(String[] args) {

        Order order= <span class="hljs-built_in">new</span> Order();

        try{

            order.checkNullParam();

            order.checkSecurity ();

            order.checkBackList();

            order2.checkRule();

            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"order success"</span>);

        }catch (RuntimeException e){

            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"order fail"</span>);

        }

    }

}</code></pre></div><p>这段代码使用了<strong>异常</strong>来做逻辑条件判断，如果后续逻辑越来越复杂的话，会出现一些问题：如异常只能返回异常信息，不能返回更多的字段，这时候需要<strong>自定义异常类</strong>。</p><p>并且，阿里开发手册规定：<strong>禁止用异常做逻辑判断</strong>。</p><blockquote><p>【强制】 异常不要用来做流程控制，条件控制。说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p></blockquote><p>如何优化这段代码呢？可以考虑<strong>责任链模式</strong></p><h4 id="2-2-责任链模式定义"><a class="headerlink" href="#2-2-责任链模式定义" title="2.2 责任链模式定义"></a>2.2 责任链模式定义</h4><p>当你想要让一个<strong>以上的对象</strong>有机会能够处理某个请求的时候，就使用<strong>责任链模式</strong>。</p><blockquote><p>责任链模式为请求创建了一个接收者对象的链。执行链上有多个对象节点，每个对象节点都有机会（条件匹配）处理请求事务，如果某个对象节点处理完了，就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p></blockquote><p>责任链模式实际上是一种处理请求的模式，它让多个处理器（对象节点）都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p><p><img lazyload="" src="/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/077775fb079a5e30fca760dbdd21de46.webp" srcset="/img/loading.gif"/></p><p>责任链模式</p><p>打个比喻：</p><blockquote><p>假设你晚上去上选修课，为了可以走点走，坐到了最后一排。来到教室，发现前面坐了好几个漂亮的小姐姐，于是你找张纸条，写上：“你好, 可以做我的女朋友吗？如果不愿意请向前传”。纸条就一个接一个的传上去了，后来传到第一排的那个妹子手上，她把纸条交给老师，听说老师 40 多岁未婚…</p></blockquote><h4 id="2-3-责任链模式使用"><a class="headerlink" href="#2-3-责任链模式使用" title="2.3 责任链模式使用"></a>2.3 责任链模式使用</h4><p>责任链模式怎么使用呢？</p><ul><li>一个接口或者抽象类</li><li>每个对象差异化处理</li><li>对象链（数组）初始化（连起来）</li></ul><h5 id="2-3-1-一个接口或者抽象类"><a class="headerlink" href="#2-3-1-一个接口或者抽象类" title="2.3.1 一个接口或者抽象类"></a>2.3.1 一个接口或者抽象类</h5><p>这个接口或者抽象类，需要：</p><ul><li>有一个指向责任下一个对象的属性</li><li>一个设置下一个对象的 set 方法</li><li>给子类对象差异化实现的方法（如以下代码的 doFilter 方法）</li></ul><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  关注公众号：捡田螺的小男孩</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

public abstract class AbstractHandler {



    <span class="hljs-comment">//责任链中的下一个对象</span>

    private AbstractHandler nextHandler;



    <span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     * 责任链的下一个对象</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     */</span>

    public void setNextHandler(AbstractHandler nextHandler){

        this.nextHandler = nextHandler;

    }



    <span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     * 具体参数拦截逻辑,给子类去实现</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     */</span>

    public void filter(Request request, Response response) {

        doFilter(request, response);

        <span class="hljs-keyword">if</span> (getNextHandler() != null) {

            getNextHandler().filter(request, response);

        }

    }



    public AbstractHandler getNextHandler() {

        <span class="hljs-keyword">return</span> nextHandler;

    }



     abstract void doFilter(Request filterRequest, Response response);



}</code></pre></div><h5 id="2-3-2-每个对象差异化处理"><a class="headerlink" href="#2-3-2-每个对象差异化处理" title="2.3.2 每个对象差异化处理"></a>2.3.2 每个对象差异化处理</h5><p>责任链上，每个对象的<strong>差异化</strong>处理，如本小节的业务场景，就有参数校验对象、安全校验对象、黑名单校验对象、规则拦截对象</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> * 参数校验对象</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> **/</span>

@Component

@Order(<span class="hljs-number">1</span>) <span class="hljs-comment">//顺序排第1，最先校验</span>

public class CheckParamFilterObject extends AbstractHandler {



    @Override

    public void doFilter(Request request, Response response) {

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"非空参数检查"</span>);

    }

}



<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  安全校验对象</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

@Component

@Order(<span class="hljs-number">2</span>) <span class="hljs-comment">//校验顺序排第2</span>

public class CheckSecurityFilterObject extends AbstractHandler {



    @Override

    public void doFilter(Request request, Response response) {

        <span class="hljs-comment">//invoke Security check</span>

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"安全调用校验"</span>);

    }

}

<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  黑名单校验对象</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

@Component

@Order(<span class="hljs-number">3</span>) <span class="hljs-comment">//校验顺序排第3</span>

public class CheckBlackFilterObject extends AbstractHandler {



    @Override

    public void doFilter(Request request, Response response) {

        <span class="hljs-comment">//invoke black list check</span>

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"校验黑名单"</span>);

    }

}



<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  规则拦截对象</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

@Component

@Order(<span class="hljs-number">4</span>) <span class="hljs-comment">//校验顺序排第4</span>

public class CheckRuleFilterObject extends AbstractHandler {



    @Override

    public void doFilter(Request request, Response response) {

        <span class="hljs-comment">//check rule</span>

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"check rule"</span>);

    }

}</code></pre></div><h5 id="2-3-3-对象链连起来（初始化）-使用"><a class="headerlink" href="#2-3-3-对象链连起来（初始化）-使用" title="2.3.3 对象链连起来（初始化）&amp;&amp; 使用"></a>2.3.3 对象链连起来（初始化）&amp;&amp; 使用</h5><div class="code-wrapper"><pre><code class="hljs go">
@Component(<span class="hljs-string">"ChainPatternDemo"</span>)

public class ChainPatternDemo {



    <span class="hljs-comment">//自动注入各个责任链的对象</span>

    @Autowired

    private List&lt;AbstractHandler&gt; abstractHandleList;



    private AbstractHandler abstractHandler;



    <span class="hljs-comment">//spring注入后自动执行，责任链的对象连接起来</span>

    @PostConstruct

    public void initializeChainFilter(){



        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;abstractHandleList.size();i++){

            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){

                abstractHandler = abstractHandleList.get(<span class="hljs-number">0</span>);

            }<span class="hljs-keyword">else</span>{

                AbstractHandler currentHander = abstractHandleList.get(i - <span class="hljs-number">1</span>);

                AbstractHandler nextHander = abstractHandleList.get(i);

                currentHander.setNextHandler(nextHander);

            }

        }

    }



    <span class="hljs-comment">//直接调用这个方法使用</span>

    public Response exec(Request request, Response response) {

        abstractHandler.filter(request, response);

        <span class="hljs-keyword">return</span> response;

    }



    public AbstractHandler getAbstractHandler() {

        <span class="hljs-keyword">return</span> abstractHandler;

    }



    public void setAbstractHandler(AbstractHandler abstractHandler) {

        this.abstractHandler = abstractHandler;

    }

}</code></pre></div><p>运行结果如下：</p><div class="code-wrapper"><pre><code class="hljs go">
非空参数检查

安全调用校验

校验黑名单

check rule</code></pre></div><h3 id="3-模板方法模式"><a class="headerlink" href="#3-模板方法模式" title="3. 模板方法模式"></a>3. 模板方法模式</h3><h4 id="3-1-业务场景"><a class="headerlink" href="#3-1-业务场景" title="3.1 业务场景"></a>3.1 业务场景</h4><p>假设我们有这么一个业务场景：内部系统不同商户，调用我们系统接口，去跟外部第三方系统交互（http 方式）。走类似这么一个流程，如下：</p><p><img lazyload="" src="/img/post/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4bf5d54fed16c8eb57e01faa3778bd86.webp" srcset="/img/loading.gif"/></p><p>一个请求都会经历这几个流程：</p><ul><li>查询商户信息</li><li>对请求报文加签</li><li>发送 http 请求出去</li><li>对返回的报文验签</li></ul><p>这里，有的商户可能是走代理出去的，有的是走直连。假设当前有 A，B 商户接入，不少伙伴可能这么实现，伪代码如下：</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">// 商户A处理句柄</span>

CompanyAHandler implements RequestHandler {

   Resp hander(req){

   <span class="hljs-comment">//查询商户信息</span>

   queryMerchantInfo();

   <span class="hljs-comment">//加签</span>

   signature();

   <span class="hljs-comment">//http请求（A商户假设走的是代理）</span>

   httpRequestbyProxy()

   <span class="hljs-comment">//验签</span>

   verify();

   }

}

<span class="hljs-comment">// 商户B处理句柄</span>

CompanyBHandler implements RequestHandler {

   Resp hander(Rreq){

   <span class="hljs-comment">//查询商户信息</span>

   queryMerchantInfo();

   <span class="hljs-comment">//加签</span>

   signature();

   <span class="hljs-comment">// http请求（B商户不走代理，直连）</span>

   httpRequestbyDirect();

   <span class="hljs-comment">// 验签</span>

   verify();

   }

}</code></pre></div><p>假设新加一个 C 商户接入，你需要再实现一套这样的代码。显然，这样代码就<strong>重复</strong>了，<strong>一些通用的方法，却在每一个子类都重新写了这一方法</strong>。</p><p>如何优化呢？可以使用<strong>模板方法模式</strong>。</p><h4 id="3-2-模板方法模式定义"><a class="headerlink" href="#3-2-模板方法模式定义" title="3.2 模板方法模式定义"></a>3.2 模板方法模式定义</h4><p>定义一个操作中的算法的骨架流程，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它的核心思想就是：定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，这样不同的子类就可以定义出不同的步骤。</p><p>打个通俗的比喻：</p><blockquote><p>模式举例：追女朋友要先“牵手”，再“拥抱”，再“接吻”， 再“拍拍..额..手”。至于具体你用左手还是右手牵，无所谓，但是整个过程，定了一个流程模板，按照模板来就行。</p></blockquote><h4 id="3-3-模板方法使用"><a class="headerlink" href="#3-3-模板方法使用" title="3.3 模板方法使用"></a>3.3 模板方法使用</h4><ul><li>一个抽象类，定义骨架流程（抽象方法放一起）</li><li>确定的共同方法步骤，放到抽象类（去除抽象方法标记）</li><li>不确定的步骤，给子类去差异化实现</li></ul><p>我们继续那以上的举例的业务流程例子，来一起用 模板方法优化一下哈：</p><h5 id="3-3-1-一个抽象类，定义骨架流程"><a class="headerlink" href="#3-3-1-一个抽象类，定义骨架流程" title="3.3.1 一个抽象类，定义骨架流程"></a>3.3.1 一个抽象类，定义骨架流程</h5><p>因为一个个请求经过的流程为一下步骤：</p><ul><li>查询商户信息</li><li>对请求报文加签</li><li>发送 http 请求出去</li><li>对返回的报文验签</li></ul><p>所以我们就可以定义一个抽象类，包含请求流程的几个方法，方法首先都定义为抽象方法哈：</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> * 抽象类定义骨架流程（查询商户信息，加签，http请求，验签）</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

abstract class AbstractMerchantService  {



      <span class="hljs-comment">//查询商户信息</span>

      abstract queryMerchantInfo();

      <span class="hljs-comment">//加签</span>

      abstract signature();

      <span class="hljs-comment">//http 请求</span>

      abstract httpRequest();

       <span class="hljs-comment">// 验签</span>

       abstract verifySinature();



}</code></pre></div><h5 id="3-3-2-确定的共同方法步骤，放到抽象类"><a class="headerlink" href="#3-3-2-确定的共同方法步骤，放到抽象类" title="3.3.2 确定的共同方法步骤，放到抽象类"></a>3.3.2 确定的共同方法步骤，放到抽象类</h5><div class="code-wrapper"><pre><code class="hljs go">
abstract class AbstractMerchantService  {



     <span class="hljs-comment">//模板方法流程</span>

     Resp handlerTempPlate(req){

           <span class="hljs-comment">//查询商户信息</span>

           queryMerchantInfo();

           <span class="hljs-comment">//加签</span>

           signature();

           <span class="hljs-comment">//http 请求</span>

           httpRequest();

           <span class="hljs-comment">// 验签</span>

           verifySinature();

     }

      <span class="hljs-comment">// Http是否走代理（提供给子类实现）</span>

      abstract boolean isRequestByProxy();

}</code></pre></div><h5 id="3-3-3-不确定的步骤，给子类去差异化实现"><a class="headerlink" href="#3-3-3-不确定的步骤，给子类去差异化实现" title="3.3.3 不确定的步骤，给子类去差异化实现"></a>3.3.3 不确定的步骤，给子类去差异化实现</h5><p>因为是否走代理流程是<strong>不确定</strong>的，所以给子类去实现。</p><p>商户 A 的请求实现：</p><div class="code-wrapper"><pre><code class="hljs go">
CompanyAServiceImpl extends AbstractMerchantService{

    Resp hander(req){

      <span class="hljs-keyword">return</span> handlerTempPlate(req);

    }

    <span class="hljs-comment">//走http代理的</span>

    boolean isRequestByProxy(){

       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    }</code></pre></div><p>商户 B 的请求实现：</p><div class="code-wrapper"><pre><code class="hljs go">
CompanyBServiceImpl extends AbstractMerchantService{

    Resp hander(req){

      <span class="hljs-keyword">return</span> handlerTempPlate(req);

    }

    <span class="hljs-comment">//公司B是不走代理的</span>

    boolean isRequestByProxy(){

       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    }</code></pre></div><h3 id="4-观察者模式"><a class="headerlink" href="#4-观察者模式" title="4. 观察者模式"></a>4. 观察者模式</h3><h4 id="4-1-业务场景"><a class="headerlink" href="#4-1-业务场景" title="4.1 业务场景"></a>4.1 业务场景</h4><p>登陆注册应该是最常见的业务场景了。就拿<strong>注册</strong>来说事，我们经常会遇到类似的场景，就是用户注册成功后，我们给用户发一条消息，又或者发个邮件等等，因此经常有如下的代码：</p><div class="code-wrapper"><pre><code class="hljs go">
void register(User user){

  insertRegisterUser（user）;

  sendIMMessage();

  sendEmail()；

}</code></pre></div><p>这块代码会有什么问题呢？如果产品又加需求：现在注册成功的用户，再给用户发一条短信通知。于是你又得改 register 方法的代码了。。。这是不是违反了<strong>开闭原则</strong>啦。</p><div class="code-wrapper"><pre><code class="hljs go">
void register(User user){

  insertRegisterUser（user）;

  sendIMMessage();

  sendMobileMessage（）;

  sendEmail()；

}</code></pre></div><p>并且，如果调<strong>发短信的接口失败</strong>了，是不是又影响到用户注册了？！这时候，是不是得加个异步方法给<strong>通知消息</strong>才好。。。</p><p>实际上，我们可以使用观察者模式优化。</p><h4 id="4-2-观察者模式定义"><a class="headerlink" href="#4-2-观察者模式定义" title="4.2 观察者模式定义"></a>4.2 观察者模式定义</h4><blockquote><p>观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新。</p></blockquote><p>观察者模式属于行为模式，一个对象（被观察者）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。它的主要成员就是<strong>观察者和被观察者</strong>。</p><ul><li>被观察者（Observerable）：目标对象，状态发生变化时，将通知所有的观察者。</li><li>观察者（observer）：接受被观察者的状态变化通知，执行预先定义的业务。</li></ul><p><strong>使用场景：</strong> 完成某件事情后，异步通知场景。如，登陆成功，发个 IM 消息等等。</p><h4 id="4-3-观察者模式使用"><a class="headerlink" href="#4-3-观察者模式使用" title="4.3 观察者模式使用"></a>4.3 观察者模式使用</h4><p>观察者模式实现的话，还是比较简单的。</p><ul><li>一个被观察者的类 Observerable ;</li><li>多个观察者 Observer ；</li><li>观察者的差异化实现</li><li>经典观察者模式封装：EventBus 实战</li></ul><h5 id="4-3-1-一个被观察者的类-Observerable-和-多个观察者-Observer"><a class="headerlink" href="#4-3-1-一个被观察者的类-Observerable-和-多个观察者-Observer" title="4.3.1 一个被观察者的类 Observerable 和 多个观察者 Observer"></a>4.3.1 一个被观察者的类 Observerable 和 多个观察者 Observer</h5><div class="code-wrapper"><pre><code class="hljs go">
public class Observerable {



   private List&lt;Observer&gt; observers

      = <span class="hljs-built_in">new</span> ArrayList&lt;Observer&gt;();

   private <span class="hljs-type">int</span> state;



   public <span class="hljs-type">int</span> getState() {

      <span class="hljs-keyword">return</span> state;

   }



   public void setState(<span class="hljs-type">int</span> state) {

      notifyAllObservers();

   }



   <span class="hljs-comment">//添加观察者</span>

   public void addServer(Observer observer){

      observers.add(observer);

   }



   <span class="hljs-comment">//移除观察者</span>

   public void removeServer(Observer observer){

      observers.remove(observer);

   }

   <span class="hljs-comment">//通知</span>

   public void notifyAllObservers(<span class="hljs-type">int</span> state){

      <span class="hljs-keyword">if</span>(state!=<span class="hljs-number">1</span>){

          System.out.<span class="hljs-built_in">println</span>(“不是通知的状态”);

         <span class="hljs-keyword">return</span> ;

      }



      <span class="hljs-keyword">for</span> (Observer observer : observers) {

         observer.doEvent();

      }

   }

}</code></pre></div><h5 id="4-3-2-观察者的差异化实现"><a class="headerlink" href="#4-3-2-观察者的差异化实现" title="4.3.2 观察者的差异化实现"></a>4.3.2 观察者的差异化实现</h5><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">//观察者</span>

 <span class="hljs-keyword">interface</span> Observer {

    void doEvent();

}

<span class="hljs-comment">//Im消息</span>

IMMessageObserver implements Observer{

    void doEvent（）{

       System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送IM消息"</span>);

    }

}



<span class="hljs-comment">//手机短信</span>

MobileNoObserver implements Observer{

    void doEvent（）{

       System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送短信消息"</span>);

    }

}

<span class="hljs-comment">//EmailNo</span>

EmailObserver implements Observer{

    void doEvent（）{

       System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送email消息"</span>);

    }

}</code></pre></div><h5 id="4-3-3-EventBus-实战"><a class="headerlink" href="#4-3-3-EventBus-实战" title="4.3.3 EventBus 实战"></a>4.3.3 EventBus 实战</h5><p>自己搞一套观察者模式的代码，还是有点小麻烦。实际上，<code>Guava EventBus</code>就封装好了，它 提供一套基于注解的事件总线，api 可以灵活的使用，爽歪歪。</p><p>我们来看下<code>EventBus</code>的实战代码哈，首先可以声明一个 EventBusCenter 类，它类似于以上被观察者那种角色<code>Observerable</code>。</p><div class="code-wrapper"><pre><code class="hljs go">
public class EventBusCenter {



    private static EventBus eventBus = <span class="hljs-built_in">new</span> EventBus();



    private EventBusCenter() {

    }



    public static EventBus getInstance() {

        <span class="hljs-keyword">return</span> eventBus;

    }

     <span class="hljs-comment">//添加观察者</span>

    public static void register(Object obj) {

        eventBus.register(obj);

    }

    <span class="hljs-comment">//移除观察者</span>

    public static void unregister(Object obj) {

        eventBus.unregister(obj);

    }

    <span class="hljs-comment">//把消息推给观察者</span>

    public static void post(Object obj) {

        eventBus.post(obj);

    }

}</code></pre></div><p>然后再声明观察者<code>EventListener</code></p><div class="code-wrapper"><pre><code class="hljs go">
public class EventListener {



    @Subscribe <span class="hljs-comment">//加了订阅，这里标记这个方法是事件处理方法</span>

    public void handle(NotifyEvent notifyEvent) {

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送IM消息"</span> + notifyEvent.getImNo());

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送短信消息"</span> + notifyEvent.getMobileNo());

        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送Email消息"</span> + notifyEvent.getEmailNo());

    }

}



<span class="hljs-comment">//通知事件类</span>

public class NotifyEvent  {



    private String mobileNo;



    private String emailNo;



    private String imNo;



    public NotifyEvent(String mobileNo, String emailNo, String imNo) {

        this.mobileNo = mobileNo;

        this.emailNo = emailNo;

        this.imNo = imNo;

    }

 }</code></pre></div><p>使用 demo 测试：</p><div class="code-wrapper"><pre><code class="hljs go">
public class EventBusDemoTest {



    public static void main(String[] args) {



        EventListener eventListener = <span class="hljs-built_in">new</span> EventListener();

        EventBusCenter.register(eventListener);

        EventBusCenter.post(<span class="hljs-built_in">new</span> NotifyEvent(<span class="hljs-string">"13372817283"</span>, <span class="hljs-string">"123@qq.com"</span>, <span class="hljs-string">"666"</span>));

        }

}</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs go">
发送IM消息<span class="hljs-number">666</span>

发送短信消息<span class="hljs-number">13372817283</span>

发送Email消息<span class="hljs-number">123</span>@qq.com</code></pre></div><h3 id="5-工厂模式"><a class="headerlink" href="#5-工厂模式" title="5. 工厂模式"></a>5. 工厂模式</h3><h4 id="5-1-业务场景"><a class="headerlink" href="#5-1-业务场景" title="5.1 业务场景"></a>5.1 业务场景</h4><p>工厂模式一般配合策略模式一起使用。用来去优化大量的<code>if...else...</code>或<code>switch...case...</code>条件语句。</p><p>我们就取第一小节中策略模式那个例子吧。根据不同的文件解析类型，创建不同的解析对象</p><div class="code-wrapper"><pre><code class="hljs go">
IFileStrategy getFileStrategy(FileTypeResolveEnum fileType){

     IFileStrategy  fileStrategy ;

     <span class="hljs-keyword">if</span>(fileType=FileTypeResolveEnum.File_A_RESOLVE){

       fileStrategy = <span class="hljs-built_in">new</span> AFileResolve();

     }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fileType=FileTypeResolveEnum.File_A_RESOLV){

       fileStrategy = <span class="hljs-built_in">new</span> BFileResolve();

     }<span class="hljs-keyword">else</span>{

       fileStrategy = <span class="hljs-built_in">new</span> DefaultFileResolve();

     }

     <span class="hljs-keyword">return</span> fileStrategy;

 }</code></pre></div><p>其实这就是<strong>工厂模式</strong>，定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>策略模式的例子，没有使用上一段代码，而是借助 spring 的特性，搞了一个工厂模式，哈哈，小伙伴们可以回去那个例子细品一下，我把代码再搬下来，小伙伴们再品一下吧：</p><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> *  @author 公众号：捡田螺的小男孩</span>
<span class="hljs-comment"></span>
<span class="hljs-comment"> */</span>

@Component

public class StrategyUseService implements ApplicationContextAware{



    private Map&lt;FileTypeResolveEnum, IFileStrategy&gt; iFileStrategyMap = <span class="hljs-built_in">new</span> ConcurrentHashMap&lt;&gt;();



    <span class="hljs-comment">//把所有的文件类型解析的对象，放到map，需要使用时，信手拈来即可。这就是工厂模式的一种体现啦</span>

    @Override

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {

        Map&lt;String, IFileStrategy&gt; tmepMap = applicationContext.getBeansOfType(IFileStrategy.class);

        tmepMap.values().forEach(strategyService -&gt; iFileStrategyMap.put(strategyService.gainFileType(), strategyService));

    }

}</code></pre></div><h4 id="5-2-使用工厂模式"><a class="headerlink" href="#5-2-使用工厂模式" title="5.2 使用工厂模式"></a>5.2 使用工厂模式</h4><p>定义工厂模式也是比较简单的:</p><ul><li>一个工厂接口，提供一个创建不同对象的方法。</li><li>其子类实现工厂接口，构造不同对象</li><li>使用工厂模式</li></ul><h5 id="5-3-1-一个工厂接口"><a class="headerlink" href="#5-3-1-一个工厂接口" title="5.3.1 一个工厂接口"></a>5.3.1 一个工厂接口</h5><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-keyword">interface</span> IFileResolveFactory{

   void resolve();

}</code></pre></div><h5 id="5-3-2-不同子类实现工厂接口"><a class="headerlink" href="#5-3-2-不同子类实现工厂接口" title="5.3.2 不同子类实现工厂接口"></a>5.3.2 不同子类实现工厂接口</h5><div class="code-wrapper"><pre><code class="hljs go">
class AFileResolve implements IFileResolveFactory{

   void resolve(){

      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"文件A类型解析"</span>);

   }

}



class BFileResolve implements IFileResolveFactory{

   void resolve(){

      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"文件B类型解析"</span>);

   }

}



class DefaultFileResolve implements IFileResolveFactory{

   void resolve(){

      System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"默认文件类型解析"</span>);

   }

}</code></pre></div><h4 id="5-3-3-使用工厂模式"><a class="headerlink" href="#5-3-3-使用工厂模式" title="5.3.3 使用工厂模式"></a>5.3.3 使用工厂模式</h4><div class="code-wrapper"><pre><code class="hljs go">
<span class="hljs-comment">//构造不同的工厂对象</span>

IFileResolveFactory fileResolveFactory;

<span class="hljs-keyword">if</span>(fileType=“A”){

    fileResolveFactory = <span class="hljs-built_in">new</span> AFileResolve();

}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fileType=“B”){

    fileResolveFactory = <span class="hljs-built_in">new</span> BFileResolve();

 }<span class="hljs-keyword">else</span>{

    fileResolveFactory = <span class="hljs-built_in">new</span> DefaultFileResolve();

}



fileResolveFactory.resolve();</code></pre></div><p>一般情况下，对于工厂模式，你不会看到以上的代码。工厂模式会跟配合其他设计模式如策略模式一起出现的。</p><h3 id="6-单例模式"><a class="headerlink" href="#6-单例模式" title="6. 单例模式"></a>6. 单例模式</h3><h4 id="6-1-业务场景"><a class="headerlink" href="#6-1-业务场景" title="6.1 业务场景"></a>6.1 业务场景</h4><p>单例模式，<strong>保证一个类仅有一个实例</strong>，并提供一个访问它的全局访问点。I/O 与数据库的连接,一般就用单例模式实现 de 的。Windows 里面的 Task Manager（任务管理器）也是很典型的单例模式。</p><p>来看一个单例模式的例子</p><div class="code-wrapper"><pre><code class="hljs go">
public class LanHanSingleton {



    private static LanHanSingleton instance;



    private LanHanSingleton(){



    }



    public static LanHanSingleton getInstance(){

        <span class="hljs-keyword">if</span> (instance == null) {

            instance = <span class="hljs-built_in">new</span> LanHanSingleton();

        }

        <span class="hljs-keyword">return</span> instance;

    }



}</code></pre></div><p>以上的例子，就是<strong>懒汉式</strong>的单例实现。实例在需要用到的时候，才去创建，就比较懒。如果有则返回，没有则新建，需要加下 <code>synchronized</code>关键字，要不然可能存在<strong>线性安全问题</strong>。</p><h4 id="6-2-单例模式的经典写法"><a class="headerlink" href="#6-2-单例模式的经典写法" title="6.2 单例模式的经典写法"></a>6.2 单例模式的经典写法</h4><p>其实单例模式还有有好几种实现方式，如饿汉模式，双重校验锁，静态内部类，枚举等实现方式。</p><h5 id="6-2-1-饿汉模式"><a class="headerlink" href="#6-2-1-饿汉模式" title="6.2.1 饿汉模式"></a>6.2.1 饿汉模式</h5><div class="code-wrapper"><pre><code class="hljs go">
public class EHanSingleton {



   private static EHanSingleton instance = <span class="hljs-built_in">new</span> EHanSingleton();



   private EHanSingleton(){

   }



   public static EHanSingleton getInstance() {

       <span class="hljs-keyword">return</span> instance;

   }



}</code></pre></div><p>饿汉模式，它<strong>比较饥饿、比较勤奋</strong>，实例在初始化的时候就已经建好了，不管你后面有没有用到，都先新建好实例再说。这个就没有线程安全的问题，但是呢，浪费内存空间呀。</p><h5 id="6-2-2-双重校验锁"><a class="headerlink" href="#6-2-2-双重校验锁" title="6.2.2 双重校验锁"></a>6.2.2 双重校验锁</h5><div class="code-wrapper"><pre><code class="hljs go">
public class DoubleCheckSingleton {



   private volatile static DoubleCheckSingleton instance;



   private DoubleCheckSingleton() { }



   public static DoubleCheckSingleton getInstance(){

       <span class="hljs-keyword">if</span> (instance == null) {

           synchronized (DoubleCheckSingleton.class) {

               <span class="hljs-keyword">if</span> (instance == null) {

                   instance = <span class="hljs-built_in">new</span> DoubleCheckSingleton();

               }

           }

       }

       <span class="hljs-keyword">return</span> instance;

   }

}</code></pre></div><p>双重校验锁实现的单例模式，综合了懒汉式和饿汉式两者的优缺点。以上代码例子中，在 synchronized 关键字内外都加了一层 <code>if</code>条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。</p><h5 id="6-2-3-静态内部类"><a class="headerlink" href="#6-2-3-静态内部类" title="6.2.3 静态内部类"></a>6.2.3 静态内部类</h5><div class="code-wrapper"><pre><code class="hljs go">
public class InnerClassSingleton {



   private static class InnerClassSingletonHolder{

       private static final InnerClassSingleton INSTANCE = <span class="hljs-built_in">new</span> InnerClassSingleton();

   }



   private InnerClassSingleton(){}



   public static final InnerClassSingleton getInstance(){

       <span class="hljs-keyword">return</span> InnerClassSingletonHolder.INSTANCE;

   }

}</code></pre></div><p>静态内部类的实现方式，效果有点类似双重校验锁。但这种方式只适用于静态域场景，双重校验锁方式可在实例域需要延迟初始化时使用。</p><h5 id="6-2-4-枚举"><a class="headerlink" href="#6-2-4-枚举" title="6.2.4 枚举"></a>6.2.4 枚举</h5><div class="code-wrapper"><pre><code class="hljs go">
public enum SingletonEnum {



    INSTANCE;

    public SingletonEnum getInstance(){

        <span class="hljs-keyword">return</span> INSTANCE;

    }

}</code></pre></div><p>枚举实现的单例，代码简洁清晰。并且它还自动支持序列化机制，绝对防止多次实例化。</p></div><hr/><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a class="category-chain-item" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="print-no-link" href="/tags/%E8%AE%BE%E8%AE%A1/">#设计</a></div><div class="post-meta" style="margin-left: auto"><a class="print-no-link" href="https://github.com/nichuanfang/hexo-blog/edit/main/posts/工作中重要的设计模式/index.md" target="_blank"><span aria_label="hexo-blog" class="hint--top hint--rounded" style="color: #007bff"><i class="iconfont icon-pen">在Github上编辑本页</i></span></a></div></div><div class="license-box my-3"><div class="license-title"><div>工作中重要的设计模式</div><div>https://blog.chuanfang.org/2024/09/12/工作中重要的设计模式/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Nichuanfang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年9月12日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年9月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" href="https://creativecommons.org/licenses/by/4.0/" target="_blank"><span aria-label="BY - 署名" class="hint--top hint--rounded"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2024/07/05/%E9%80%86%E5%90%91%E5%BF%83%E5%BE%97/" title="逆向心得"><span class="hidden-mobile">逆向心得</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload=""><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"enOFHBl7E8Mh2ZLlcjZ679m0-gzGzoHsz",appKey:"eZI7IWrl3Nq2PqR3CLZhsqTg",path:"window.location.pathname",placeholder:"说点什么吧...",avatar:"mp",meta:["nick","mail","link"],requiredFields:["nick"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a aria-label="TOP" href="#" id="scroll-top-button" role="button"><i aria-hidden="true" class="iconfont icon-arrowup"></i></a><div aria-hidden="true" aria-labelledby="ModalLabel" class="modal fade" id="modalSearch" role="dialog" tabindex="-1"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button aria-label="Close" class="close" data-dismiss="modal" id="local-search-close" type="button"><span aria-hidden="true">×</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input class="form-control validate" id="local-search-input" type="text"/> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><div id="aplayer"></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"/><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/side_bg.js"></script><script src="/js/APlayer.min.js"></script><script src="/js/useaplayer.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>